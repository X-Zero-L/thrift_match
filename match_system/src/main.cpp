// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "match_server/Match.h"
#include "save_client/Save.h"

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

// 引入多线程相关的头文件
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/ThreadFactory.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/TToString.h>

#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>

#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <vector>
#include <unistd.h> // 用于调用sleep函数

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::match_service;
using namespace  ::save_service;


using namespace std;
// 建立生产者消费者模型

struct Task  // 消息队列中的元素
{
  User user;
  string type;
};

struct MessageQueue  // 消息队列
{
  queue<Task> q;//消息队列本体
  mutex m; // 互斥信号量
  condition_variable cv; // 条件变量，用于阻塞唤醒线程
}message_queue;

class Pool // 模拟匹配池
{
  private: // 对匹配池中的用户用vector记录
    vector<User> users;
    vector<int> wt;//wait_time 记录每个用户的等待时间

  public:
    void save_result(int a,int b) // 记录成功匹配的信息
    {
      printf("Match Result: %d %d\n",a,b);

      //建立连接用，thrift官网模板处复制即可
      /*std::shared_ptr<TTransport> socket(new TSocket("localhost", 9090));
      std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
      std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
      SaveClient client(protocol);

      try {
        transport->open();//建立连接

        int res = client.save_data("root","97830837",a,b);
        //↑调用接口发送数据
        if(!res) puts("success");
        else puts("fail");
      }
      catch (TException& tx) {
        cout << "ERROR: " << tx.what() << endl;
      }*/
    }

    bool check(int i,int j)//判断两个玩家是否可以匹配
    {
      User a = users[i],b=users[j];
      int diff = abs(a.score-b.score);
      int a_diff_max = wt[i]*50;
      int b_diff_max = wt[j]*50;
      return diff <= a_diff_max && diff <= b_diff_max;
    }

    void match()  // 匹配池中的第一个和第二个用户进行匹配
    {
      for(auto &t:wt)
        t++;//每次调用match时，wt自增1，增加当前所有用户的等待时间
      while(users.size()>1)
      {
        //auto a = users[0],b=users[1];
        //users.erase(users.begin());
        //users.erase(users.begin());
        //save_result(a.id,b.id);

        // 实现按照rank差进行匹配的逻辑
        // 1.先对users按照rank进行升序排序
        /*sort(users.begin(),users.end(),[&](User &a,User &b){
          return a.score < b.score;
        });*/
        // 2.遍历users对分差小于某个值的玩家进行匹配
        bool flag=true;
        /*for(uint32_t i = 1;i< users.size() ;i++)
        {
          User a = users[i-1],b = users[i];
          //printf("a.score:%d,b.score:%d\n",a.score,b.score);
          if(b.score-a.score<=50)
          {
            //printf("a.score:%d,b.score:%d\n",a.score,b.score);
            users.erase(users.begin()+i-1,users.begin()+i);
            //匹配成功则在匹配池中删去这两个用户,然后发送数据至存储服务端
            save_result(a.id,b.id);
            flag = false;
            break;
          }
        }*///原有的匹配方式对原rank进行排序，不适合新的匹配方式
        for(uint32_t i = 0;i<users.size();i++)
        {
          for(uint32_t j=i+1;j<users.size();j++)
          {
            if(check(i,j))
            {
              save_result(users[i].id,users[j].id);
              users.erase(users.begin()+j);
              users.erase(users.begin()+i);
              wt.erase(wt.begin()+j);
              wt.erase(wt.begin()+i);
              flag=false;
              break;
            }
            if(!flag) break;//匹配成功退出
          }
        }
        if(flag) break;//未能成功匹配，等待下次调用
      }
    }

    void add(User user) // 向匹配池中加入用户
    {
      users.push_back(user);
      wt.push_back(0);
    }

    void remove(User user)
    {
      for (uint32_t i=0;i<users.size();i++)
      {
        if(users[i].id==user.id)
        {
          users.erase(users.begin()+i);
          break;
        }
      }
    }
}pool;

class MatchHandler : virtual public MatchIf {  // 客户端传输过来的信息统一在这进行调用
 public:
  MatchHandler() {
    // Your initialization goes here
  }

  int32_t add_user(const User& user, const std::string& info) {
    // Your implementation goes here
    printf("add_user\n");

    unique_lock<mutex> lck(message_queue.m);//访问临界区(消息队列),先上锁
    message_queue.q.push({user,"add"});// 把新消息加入消息队列
    message_queue.cv.notify_all();//唤醒阻塞的线程

    return 0;
  }

  int32_t remove_user(const User& user, const std::string& info) {
    // Your implementation goes here
    printf("remove_user\n");
    
    unique_lock<mutex> lck(message_queue.m);//同上
    message_queue.q.push({user,"remoev"});
    message_queue.cv.notify_all();

    return 0;
  }

};

// 从thrift官网处复制模板的类 CalculatorCloneFactory，把所有的 Calculator 改为 Match
class MatchCloneFactory : virtual public MatchIfFactory {
    public:
        ~MatchCloneFactory() override = default;
        MatchIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) override
        {
            std::shared_ptr<TSocket> sock = std::dynamic_pointer_cast<TSocket>(connInfo.transport);
            /*
            cout << "Incoming connection\n";
            cout << "\tSocketInfo: "  << sock->getSocketInfo() << "\n";
            cout << "\tPeerHost: "    << sock->getPeerHost() << "\n";
            cout << "\tPeerAddress: " << sock->getPeerAddress() << "\n";
            cout << "\tPeerPort: "    << sock->getPeerPort() << "\n";
            */
            return new MatchHandler;
        }
        void releaseHandler(MatchIf* handler) override {    //改为MatchIf*  
            delete handler;
        }
};

//基于生产者消费者模型的线程
void consume_task()
{
  while(true)
  {
    unique_lock<mutex> lck(message_queue.m);//访问临界区时上锁

    if(message_queue.q.empty())
    {
      //message_queue.cv.wait(lck);
      //队列为空时阻塞进程，避免反复运行导致一直占用临界区

      //修改为每秒进行一次匹配，而不是等待唤醒
      //sleep(1);
      lck.unlock();
      pool.match();
    }
    else
    {
      auto task = message_queue.q.front();
      message_queue.q.pop();

      lck.unlock();//临界区访问结束，直接解锁
      //避免长时间占用临界区

      if (task.type=="add") pool.add(task.user);
      else if(task.type=="remove") pool.remove(task.user);

      pool.match();
    }
  }
}

int main(int argc, char **argv) {
  /*int port = 9090;
  ::std::shared_ptr<MatchHandler> handler(new MatchHandler());
  ::std::shared_ptr<TProcessor> processor(new MatchProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  */
  TThreadedServer server(//改为多线程支持
            std::make_shared<MatchProcessorFactory>(std::make_shared<MatchCloneFactory>()),
            std::make_shared<TServerSocket>(9090), //port
            std::make_shared<TBufferedTransportFactory>(),
            std::make_shared<TBinaryProtocolFactory>());

  cout << "Start Match Server" << endl;

  thread matching_thread(consume_task); // 调用一个线程运行consume_task

  server.serve();
  
  return 0;
}

